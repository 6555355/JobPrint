/* 
	版权所有 2006－2007，北京博源恒芯科技有限公司。保留所有权利。
	只有被北京博源恒芯科技有限公司授权的单位才能更改抄写和传播。
	CopyRight 2006-2007, Beijing BYHX Technology Co., Ltd. All Rights reserved.
	All information contained in this file is the confindential property of Beijing BYHX Technology Co., Ltd.
	This file is distributed under license and may not be copied,
	modified or distributed except as expressly authorized by BYHX Technology Co., Ltd.
*/

#include "StdAfx.h"
#include "ParserPub.h"
#include "BandDataPrepare.h"
#include "DataPub.h"
#include <assert.h>
#include "HeadAttribute.h"
#include "ParserLog.h"
#include "temp.hpp"
#include "efficient bit manipulation.h"
#include "PerformTest.h"
#include "TcpPackageStruct.h"
static int Kyocera_Table_YH600[] = 
{
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 480,
	170, 250, 90, 260, 100, 180, 20, 460, 150, 230, 70, 240, 80, 160, 0, 480,
	170, 250, 90, 410, 100, 180, 20, 460, 150, 230, 70, 390, 80, 160, 0, 480,
	170, 400, 90, 410, 100, 180, 20, 460, 150, 380, 70, 390, 80, 160, 0, 480,
	170, 400, 90, 410, 100, 330, 20, 460, 150, 380, 70, 390, 80, 310, 0, 480,
	320, 400, 90, 410, 100, 330, 20, 460, 300, 380, 70, 390, 80, 310, 0, 480,
	320, 400, 90, 410, 250, 330, 20, 460, 300, 380, 70, 390, 230, 310, 0, 480,
	320, 400, 240, 410, 250, 330, 20, 460, 300, 380, 220, 390, 230, 310, 0, 480,

	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 0, 480,
	320, 400, 240, 410, 250, 330, 20, 460, 300, 380, 70, 390, 230, 310, 0, 480,
	320, 400, 90, 410, 250, 330, 20, 460, 300, 380, 70, 390, 80, 310, 0, 480,
	320, 400, 90, 410, 100, 330, 20, 460, 150, 380, 70, 390, 80, 310, 0, 480,
	170, 400, 90, 410, 100, 330, 20, 460, 150, 380, 70, 390, 80, 160, 0, 480,
	170, 400, 90, 410, 100, 180, 20, 460, 150, 230, 70, 390, 80, 160, 0, 480,
	170, 250, 90, 410, 100, 180, 20, 460, 150, 230, 70, 240, 80, 160, 0, 480,

	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 330,
	
	170, 250, 90, 260, 100, 180, 20, 310, 150, 230, 70, 240, 80, 160, 0, 480,
	170, 250, 90, 260, 100, 180, 20, 460, 150, 230, 70, 240, 80, 160, 0, 480,
	170, 250, 90, 410, 100, 180, 20, 460, 150, 230, 70, 390, 80, 160, 0, 480,
	170, 400, 90, 410, 100, 180, 20, 460, 150, 380, 70, 390, 80, 160, 0, 480,
	170, 400, 90, 410, 100, 330, 20, 460, 150, 380, 70, 390, 80, 310, 0, 480,
	320, 400, 90, 410, 100, 330, 20, 460, 300, 380, 70, 390, 80, 310, 0, 480,
	320, 400, 90, 410, 250, 330, 20, 460, 300, 380, 70, 390, 230, 310, 0, 480,
	320, 400, 240, 410, 250, 330, 20, 460, 300, 380, 220, 390, 230, 310, 0, 480,

	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,
	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 150, 480,

	320, 400, 240, 410, 250, 330, 170, 460, 300, 380, 220, 390, 230, 310, 0, 480,
	//320, 400, 240, 410, 250, 330, 20, 460, 300, 380, 70, 390, 230, 310, 0, 480,
	//320, 400, 90, 410, 250, 330, 20, 460, 300, 380, 70, 390, 80, 310, 0, 480,
	//320, 400, 90, 410, 100, 330, 20, 460, 150, 380, 70, 390, 80, 310, 0, 480,
	//170, 400, 90, 410, 100, 330, 20, 460, 150, 380, 70, 390, 80, 160, 0, 480,
	//170, 400, 90, 410, 100, 180, 20, 460, 150, 230, 70, 390, 80, 160, 0, 480,
	//170, 250, 90, 410, 100, 180, 20, 460, 150, 230, 70, 240, 80, 160, 0, 480,
	//------------------------------------

	

};
static int Kyocera_Table[] = 
{
	//Unit1 0-34(16排）
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,

	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,

	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,

	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	////////////////		///////////	////////////////	////////////////
	////8 Line  InterLeave Unit	1 and Unit2	（8排）		
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,396,
	148,220,78,232,		90,160,18,378, 	130,202,60,214, 	72,142,0,396,
	148,220,78,336,		90,160,18,378, 	130,202,60,318, 	72,142,0,396,
	148,324,78,336,		90,160,18,378, 	130,306,60,318, 	72,142,0,396,

	148,324,78,336,		90,266,18,378, 	130,306,60,318,		72,248,0,396,
	254,324,78,336,		90,266,18,378, 	236,306,60,318,		72,248,0,396,
	254,324,78,336,		194,266,18,378,	236,306,60,318,		176,248,0,396,
	254,324,182,336,	194,266,18,378,	236,306,164,318,	176,248,0,396,
					 				   	
	/////34 Line Unit2	：	   	
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
					 		
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
					 		
					 		
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
					 		
	254,324,182,336, 	194,266,124,378,	 236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378,	 236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378,	 236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378,	 236,306,164,318, 	176,248,106,396,
					 										  	
					 										  	
	/////////////////		////////////	//////////////////	////////////
	////7 Line  Intet		Leave Unit2 	and Unit3	（7排）	  	
	254,324,182,336, 	194,266,124,378,	236,306,164,318, 	176,248,0,396,
	254,324,182,336, 	194,266,18,378,		236,306,60,318, 	176,248,0,396,
	254,324,78,336, 	194,266,18,378,		236,306,60,318, 	72,248,0,396,
	254,324,78,336, 	90,266,18,378,		130,306,60,318, 	72,248,0,396,

	148,324,78,336, 	90,266,18,378,		130,306,60,318, 	72,142,0,396,
	148,324,78,336, 	90,160,18,378,		130,202,60,318, 	72,142,0,396,
	148,220,78,336, 	90,160,18,378,		130,202,60,214, 	72,142,0,396,


	//Unit3 0-34
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272,	130,202,60,214, 	72,142,0,290,

	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,

	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,

	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,290,
	////////////////		///////////	////////////////	////////////////
	////8 Line  InterLeave Unit	3 and Unit4 same with 1,2	（8排）		

	//////////////////////////////////////////////////////////////////////////
	148,220,78,232,		90,160,18,272, 	130,202,60,214, 	72,142,0,396,
	148,220,78,232,		90,160,18,378, 	130,202,60,214, 	72,142,0,396,
	148,220,78,336,		90,160,18,378, 	130,202,60,318, 	72,142,0,396,
	148,324,78,336,		90,160,18,378, 	130,306,60,318, 	72,142,0,396,

	148,324,78,336,		90,266,18,378, 	130,306,60,318,		72,248,0,396,
	254,324,78,336,		90,266,18,378, 	236,306,60,318,		72,248,0,396,
	254,324,78,336,		194,266,18,378,	236,306,60,318,		176,248,0,396,
	254,324,182,336,	194,266,18,378,	236,306,164,318,	176,248,0,396,

					 				   	
	/////34 Line Unit4		   	
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336,	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
					 		
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
					 		
					 		
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378, 	236,306,164,318, 	176,248,106,396,
					 		
	254,324,182,336, 	194,266,124,378,	 236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378,	 236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378,	 236,306,164,318, 	176,248,106,396,
	254,324,182,336, 	194,266,124,378,	 236,306,164,318, 	176,248,106,396,
					 										  	
					 										  	
	/////////////////		////////////	//////////////////	////////////
	////7 Line  Intet		Leave Unit2 	and Unit3		  	
	254,324,182,336, 	194,266,124,378,	236,306,164,318, 	176,248,0,396,
	//254,324,182,336, 	194,266,18,378,		236,306,60,318, 	176,248,0,396,
	//254,324,78,336, 	194,266,18,378,		236,306,60,318, 	72,248,0,396,
	//254,324,78,336, 	90,266,18,378,		130,306,60,318, 	72,248,0,396,

	//148,324,78,336, 	90,266,18,378,		130,306,60,318, 	72,142,0,396,
	//148,324,78,336, 	90,160,18,378,		130,202,60,318, 	72,142,0,396,
	//148,220,78,336, 	90,160,18,378,		130,202,60,214, 	72,142,0,396,
};


CBandDataPrepare::CBandDataPrepare()
{
	m_pSerialBuf = new unsigned char [SERIAL_SIZE];
	m_pCacheLineBuf = 0;
	m_GroupTable = NULL;
	m_nLeftAngleOffset= m_nRightAngleOffset = 0;
	m_nMBoardNum = 0;
}
CBandDataPrepare::~CBandDataPrepare()
{
	if(m_pSerialBuf)
	{
		delete m_pSerialBuf;
		m_pSerialBuf = 0;
	}
	if(m_nLeftAngleOffset)
	{
		delete m_nLeftAngleOffset;
		m_nLeftAngleOffset = 0;
	}
	if(m_nRightAngleOffset)
	{
		delete m_nRightAngleOffset;
		m_nRightAngleOffset = 0;
	}
}

int CBandDataPrepare::PrePrintJob(CParserJob* pJob,int JobWidth)
{
	m_pParserJob = pJob;
	m_nOutputColorDeep = pJob->get_SPrinterProperty()->get_OutputColorDeep();
	m_nHeadNum = pJob->get_HeadNum();
	m_nPrinterColorNum = pJob->get_SPrinterProperty()->get_PrinterColorNum();
	m_nYGroupNum = GlobalLayoutHandle->GetRowNum();//pJob->get_SPrinterProperty()->get_HeadNumPerGroupY();
	m_nXGroupNum = pJob->get_SPrinterProperty()->get_HeadNumPerGroupX();
	m_nOneHeadNum = pJob->get_SPrinterProperty()->get_HeadNumPerColor();
	m_nInputNum = pJob->get_SPrinterProperty()->get_HeadInputNum();
	for (int i=0;i<m_nInputNum;i++)
		m_InputMap[i] = i;
	m_nHeadNumDoubleX = pJob->get_SPrinterProperty()->get_HeadNumDoubleX();
	m_nMaxLeftOffset = pJob->get_MaxXOffset(true);
	m_nMaxRightOffset = pJob->get_MaxXOffset(false);
	pJob->get_XOffset(m_nLeftOffset,true);
	pJob->get_XOffset(m_nRightOffset,false);

	if (m_nOneHeadNum*m_nPrinterColorNum*m_nYGroupNum <= 128)
	{
		LogBinArray(m_nLeftOffset, "Left Offset:", m_nPrinterColorNum * m_nYGroupNum, m_nOneHeadNum);
		LogBinArray(m_nRightOffset, "Right Offset:", m_nPrinterColorNum * m_nYGroupNum, m_nOneHeadNum);
	}

	m_nRotateLineNum = pJob->get_ElectricNum();
	m_nMBoardNum = max(GlobalPrinterHandle->GetSettingManager()->get_MultMbSetting()->MbCount,1);

	m_bIsPosHeadInElectric = pJob->get_SPrinterProperty()->get_HeadElectricReverse();
	int head = pJob->get_SPrinterProperty()->get_PrinterHead();
	m_bIsPosHeadInGroup = false;

	if(pJob->get_IsWhiteInkReverse())
	{
		m_bIsPosHeadInElectric = !m_bIsPosHeadInElectric;
		m_bIsPosHeadInGroup = true;
		LogfileStr("PrePrintJob get_IsWhiteInkReverse=%d;",pJob->get_IsWhiteInkReverse());
	}

	m_nBytePerPixel = (m_nRotateLineNum + 7)/8;;
	m_nSerialNum = (m_nHeadNum / m_nMBoardNum * m_nInputNum + m_nRotateLineNum - 1)/m_nRotateLineNum;
	//Note this is only for USB2.0 use it,in other system should have no this limit
	if(m_nSerialNum == 3 && m_nBytePerPixel == 1)
		m_nSerialNum = 4;

	ConstructGroupTable(pJob);

	

	if(JobWidth<0)
		m_nJobWidth = pJob->get_SJobInfo()->sLogicalPage.width + pJob->get_ColorBarWidth();
	else
		m_nJobWidth = JobWidth;
	
	m_nBandWidth = m_nJobWidth + max(m_nMaxLeftOffset,m_nMaxRightOffset);

	m_nBandWidth = (m_nBandWidth + BIT_PACK_LEN - 1) / BIT_PACK_LEN * BIT_PACK_LEN;

	m_nRotationBytePerLine = (pJob->get_SPrinterProperty()->get_NozzleNum() / m_nInputNum / pJob->get_SPrinterProperty()->get_HeadRowNum()) * m_nSerialNum*m_nRotateLineNum / 8;
	if(m_nRotateLineNum%8==0)
		m_nRotateBitNum = 8;
	else
		m_nRotateBitNum = 4;
	m_nBandAddressSize = m_nBandWidth*m_nOutputColorDeep* m_nRotationBytePerLine;

	m_nBandMemHeight = m_nRotationBytePerLine*8; 

	int nozzle126_datawidth = pJob->get_SPrinterProperty()->get_ValidNozzleNum();
	m_bIsHaveAngle = pJob->get_IsHaveAngle();

	if (pJob->get_IsMatrixHead())
	{
		m_nLeftAngleOffset = new int[nozzle126_datawidth];
		m_nRightAngleOffset = new int[nozzle126_datawidth];

		memset(m_nLeftAngleOffset, 0, sizeof(int)* nozzle126_datawidth);
		memset(m_nRightAngleOffset, 0, sizeof(int)* nozzle126_datawidth);
		if(IsKyocera600(head))
		{
			int *pKyo_Table = Kyocera_Table;
			if(IsKyocera600H(head))
				pKyo_Table = Kyocera_Table_YH600;
			int ResolutionX = m_pParserJob->get_SJobInfo()->sPrtInfo.sFreSetting.nResolutionX;
			int max_Kyo = 0;
			for (int i=0;i<nozzle126_datawidth;i++)
			{
				if(max_Kyo < pKyo_Table[i])
					max_Kyo = pKyo_Table[i]; 
			}
			for (int i=0;i<nozzle126_datawidth;i++)
				m_nLeftAngleOffset[i] = m_nRightAngleOffset[i] = ((max_Kyo -  pKyo_Table[i])*ResolutionX/600)*m_nOutputColorDeep;
		}
	}
	else
	{
		m_nLeftAngleOffset = new int[nozzle126_datawidth];
		m_nRightAngleOffset = new int[nozzle126_datawidth];

		InitAngleOffset(pJob->get_LastNozzleAngleOffset(true),nozzle126_datawidth,m_nLeftAngleOffset,0,m_nOutputColorDeep);
		InitAngleOffset(pJob->get_LastNozzleAngleOffset(false),nozzle126_datawidth,m_nRightAngleOffset,0,m_nOutputColorDeep);
	}
	m_bKonicaOneHeadDivider = 
		((pJob->get_SPrinterProperty()->get_OneHeadDivider() == 2) && 
		IsKonica512(pJob->get_SPrinterProperty()->get_PrinterHead()));

	memset(m_bClearNozzle,0,1024*MAX_HEAD_NUM);

	memcpy(m_bClearNozzle,pJob->get_JobSetting()->bMaskNozzle,1024*MAX_HEAD_NUM);

	//Post Print
	m_bConvert16To12 = false;
	m_bPolaris4Color = false;
	m_bTiffCompress = false;
	m_bHeadMask = false;
	m_bSpectra_serial = false;
	m_bDualBandMode = false;
	m_bEpson5Compress = false;
	m_bEpson5 = false;
	m_bKm512GrayCompress = false;
	m_bEmeraldCompress = false;
	m_bKyocera = false;

	m_nCacheLineSize = 0;;
	m_pCacheLineBuf = 0;

	GetPostProcessMethod();

	int headnum = m_pParserJob->get_HeadNum();
	int leftoffset[MAX_SUB_HEAD_NUM]={0}, rightoffset[MAX_SUB_HEAD_NUM]={0}, map[MAX_SUB_HEAD_NUM]={0};
	for (int index = 0; index < headnum; index++)
	{
		leftoffset[index] = m_nLeftOffset[index];
		rightoffset[index] = m_nRightOffset[index];
		map[index] = m_GroupTable[index].m_nMapLine;
	}
	GlobalPrinterHandle->GetUsbHandle()->SendPrinterInfo(TcpPackageCmd_LEFTOFFSET,leftoffset,headnum*sizeof(int));
	GlobalPrinterHandle->GetUsbHandle()->SendPrinterInfo(TcpPackageCmd_RIGHTOFFSET,rightoffset,headnum*sizeof(int));
	GlobalPrinterHandle->GetUsbHandle()->SendPrinterInfo(TcpPackageCmd_MAP,map,headnum*sizeof(int));
	return 1;
}
int CBandDataPrepare::PostPrintJob()
{

	if (m_GroupTable!=NULL)
	{
		delete[] m_GroupTable;
		m_GroupTable=NULL;
	}
	if(m_pCacheLineBuf != 0)
	{
		delete m_pCacheLineBuf;
		m_pCacheLineBuf = 0;
	}
	if(m_nLeftAngleOffset)
	{
		delete m_nLeftAngleOffset;
		m_nLeftAngleOffset = 0;
	}
	if(m_nRightAngleOffset)
	{
		delete m_nRightAngleOffset;
		m_nRightAngleOffset = 0;
	}

	return 1;
}

void CBandDataPrepare::ConstructGroupTable(CParserJob* pJob)
{
	unsigned short* pMap = new unsigned short[MAX_ELECMAP_NUM];
	memset(pMap, 0, MAX_ELECMAP_NUM * sizeof(ushort));

	bool bFreeMap = false;
	bool bSymmetry = false;
	bSymmetry = pJob->get_SPrinterProperty()->get_InternalMap();
	bFreeMap = pJob->get_SPrinterProperty()->get_IsElectricMap();
	int dataCountPerLine = GlobalLayoutHandle->GetDataCountPerLine();
	int maxMaplen =  pJob->get_SPrinterProperty()->get_HeadNum();
//	GlobalLayoutHandle->GetDataChannel(pMap,maxMaplen);
	GlobalLayoutHandle->GetDataChannel_Multi(pMap, maxMaplen*dataCountPerLine);//kyocera
//	LogDataMap("Data Map:\n", pMap, maxMaplen*dataCountPerLine, GlobalLayoutHandle->GetColorNum()/GlobalLayoutHandle->GetHeadBoardCount()*dataCountPerLine);

	int ele_groupnum = (m_nHeadNum + m_nRotateLineNum-1)/m_nRotateLineNum;
	int groupnum = max(m_nRotateLineNum*m_nMBoardNum,MAX_HEAD_NUM);
	m_GroupTable = new SElectricHeadMap[groupnum];
	memset(m_GroupTable, 0, sizeof(SElectricHeadMap)* groupnum);
	bool bGroupIsPos = pJob->get_SPrinterProperty()->get_HeadSerialReverse();

	int ele_nullHead = 0;
	if((m_nSerialNum > 1) && bGroupIsPos && (m_nHeadNum*m_nInputNum%m_nRotateLineNum) != 0  && !bFreeMap && !bSymmetry)
		ele_nullHead = m_nRotateLineNum/m_nInputNum - (m_nHeadNum % (m_nRotateLineNum /m_nInputNum));

	int mboard_elecmapnum = m_nRotateLineNum;//m_nHeadNum*dataCountPerLine/m_nMBoardNum;
	for (int i= 0;i< m_nHeadNum*dataCountPerLine;i++)
	{
		int ele_headIndex = i;
		if(bFreeMap||bSymmetry)
			ele_headIndex = (m_nMBoardNum>1)?(pMap[i]%mboard_elecmapnum):pMap[i]; 
		//m_GroupTable[i] = new SElectricHeadMap;

		ele_headIndex = ele_headIndex + ele_nullHead;
		int ele_serIndex = (ele_headIndex*m_nInputNum)/m_nRotateLineNum;
		int ele_colorIndex = (ele_headIndex*m_nInputNum)%m_nRotateLineNum;

		m_GroupTable[i].m_nSerialIndex = ele_serIndex;

#ifdef YAN1
		if(m_nRotateLineNum>=8)//123
			m_GroupTable[i].m_nMapLine = (ele_colorIndex/8)*8 + (7- (ele_colorIndex%8));
#elif YAN2
		if(m_nRotateLineNum%32==0)
			m_GroupTable[i].m_nMapLine = (ele_colorIndex/32)*32 + (31- (ele_colorIndex%32));
		else if(m_nRotateLineNum%8==0)
			m_GroupTable[i].m_nMapLine = (ele_colorIndex/8)*8 + (7- (ele_colorIndex%8));
#endif
		else
			m_GroupTable[i].m_nMapLine = (ele_colorIndex/4)*4 + (3- (ele_colorIndex%4));
	}
	delete[] pMap;
}
int CBandDataPrepare::GetDoubleXHeadIndex(int headIndex)
{
	int nxGroupIndex, nyGroupIndex, colorIndex;
	MapHeadToGroupColor(headIndex,nxGroupIndex, nyGroupIndex, colorIndex);
	if((nyGroupIndex&1)==0)
		nyGroupIndex++;
	return ConvertToHeadIndex(nxGroupIndex,nyGroupIndex,colorIndex);
}
int CBandDataPrepare::ConvertToHeadIndex(int nxGroupIndex,int nyGroupIndex, int colorIndex, int columnNum,int columnindex)
{
#ifdef X_ARRANGE_FIRST
	int headIndex = nyGroupIndex*m_nPrinterColorNum *m_nXGroupNum*m_nOneHeadNum +  nxGroupIndex * m_nPrinterColorNum +  colorIndex;
#else
	int headIndex = GlobalLayoutHandle->GetChannelMap(nxGroupIndex,nyGroupIndex,colorIndex,columnNum,columnindex);
#endif
	return headIndex;
}
void CBandDataPrepare::MapHeadToGroupColor(int headIndex,int& nxGroupIndex,int& nyGroupIndex, int& colorIndex)
{
#ifdef X_ARRANGE_FIRST
	nyGroupIndex = headIndex/(m_nPrinterColorNum *m_nXGroupNum*m_nOneHeadNum);
	int temp = (headIndex -nyGroupIndex*m_nPrinterColorNum *m_nXGroupNum*m_nOneHeadNum);
	nxGroupIndex = (temp)/m_nPrinterColorNum;
	colorIndex = (temp)%m_nPrinterColorNum;
#else
	nxGroupIndex = headIndex/(m_nPrinterColorNum *m_nYGroupNum);
	int temp = (headIndex -nxGroupIndex*m_nPrinterColorNum *m_nYGroupNum);
	nyGroupIndex = (temp)/m_nPrinterColorNum;
	colorIndex = (temp)%m_nPrinterColorNum;
#endif
}
static void ConvertByteToShort_3Bit(uint &srcShort,  byte  srcBitH, byte  srcBitM ,byte  srcBitL)
{
	//this part can use assambly
	srcShort = 0;
	uint dstchar1 = srcBitH;
    srcShort |= 
		(
		((dstchar1&0x1) << 0 )| 
		((dstchar1&0x2) << 2 )|
		((dstchar1&0x4) << 4 )|
		((dstchar1&0x8) << 6 )|
		((dstchar1&0x10)<< 8 )|
		((dstchar1&0x20)<< 10)|
		((dstchar1&0x40)<< 12)|
		((dstchar1&0x80)<< 14)
		);
	srcShort<<=1;

	dstchar1 = srcBitM;
    srcShort |= 
		(
		((dstchar1&0x1) << 0 )| 
		((dstchar1&0x2) << 2 )|
		((dstchar1&0x4) << 4 )|
		((dstchar1&0x8) << 6 )|
		((dstchar1&0x10)<< 8 )|
		((dstchar1&0x20)<< 10)|
		((dstchar1&0x40)<< 12)|
		((dstchar1&0x80)<< 14)
		);
	srcShort<<=1;
	
	dstchar1 = srcBitL;
    srcShort |= 
		(
		((dstchar1&0x1) << 0 )| 
		((dstchar1&0x2) << 2 )|
		((dstchar1&0x4) << 4 )|
		((dstchar1&0x8) << 6 )|
		((dstchar1&0x10)<< 8 )|
		((dstchar1&0x20)<< 10)|
		((dstchar1&0x40)<< 12)|
		((dstchar1&0x80)<< 14)
		);

}

static void ConvertByteToShort(ushort &srcShort,  byte  srcHight, byte  srcLow)
{
	//this part can use assambly
	srcShort = 0;
	ushort dstchar1 = srcHight;
    srcShort |= 
		(
		((dstchar1&0x1) << 0)| 
		((dstchar1&0x2) << 1)|
		((dstchar1&0x4) << 2)|
		((dstchar1&0x8) << 3)|
		((dstchar1&0x10)<< 4)|
		((dstchar1&0x20)<< 5)|
		((dstchar1&0x40)<< 6)|
		((dstchar1&0x80)<< 7)
		);
	srcShort<<=1;
	
	dstchar1 = srcLow;
    srcShort |= 
		(
		((dstchar1&0x1) << 0)| 
		((dstchar1&0x2) << 1)|
		((dstchar1&0x4) << 2)|
		((dstchar1&0x8) << 3)|
		((dstchar1&0x10)<< 4)|
		((dstchar1&0x20)<< 5)|
		((dstchar1&0x40)<< 6)|
		((dstchar1&0x80)<< 7)
		);

}
static void ConvertResX2Short(ushort srcShort,  byte&  dstchar1, byte&  dstchar2)
{
	//this part can use assambly
	dstchar1 = 
		 (srcShort&0x3000)>>6
		|(srcShort&0x0300)>>4
		|(srcShort&0x0030)>>2
		|(srcShort&0x0003);
	
	srcShort >>=2; 
	dstchar2 = 
		 (srcShort&0x3000)>>6
		|(srcShort&0x0300)>>4
		|(srcShort&0x0030)>>2
		|(srcShort&0x0003);

}
static unsigned int PackbitsEncode(unsigned char *buf_comp, 
						   unsigned char *buf, unsigned int ilen )
{
	unsigned char c;
	unsigned char *p;
	unsigned char *cbp; /* Compressed buffer pointer */
	int i, j, last_i, end_loop;
	cbp = buf_comp;
	last_i = 0;
	end_loop = (int)(ilen - 2);
	for( p=buf, i=0; i<end_loop; p++, i++ )
	{
		if( (c = *p) != p[1] )
			continue;
		/* If only a two byte repeat, and we have literal
		** data preceeding, then it is best to send the
		** two bytes as literal data. */
		if( (i != last_i) && (c != p[2]) )
			continue;
		/* We have found a repeated string. First send out the
		** literal string in front of it if needed. */
		if( ( j = i - last_i ) > 0 )
		{
			/* dump max sized literal records first */
			while( j > 128 ) {
				*cbp++ = 128 - 1;
				memcpy( cbp, buf +last_i, 128 );
				cbp += 128;
				last_i += 128;
				j -= 128 ;
			}
			/* Send last literal record */
			*cbp++ = (byte)(j - 1);
			memcpy( cbp, buf +last_i, (unsigned int)j );
			cbp += j;
		}
		j = (int)(ilen - i - 1); /* Max we can check + 1 */
		p += 2;					   /* Start scanning two bytes ahead */
		while( --j > 0 )
		{
			if( c != *p )
				break;
			p++;
		}
		/* p now points to the first byte that doesn't compare */
		j = (int)(p - (buf +i)); /* Number of repeats */
		i += j;					/* Advance our index past repeats */
		/* Place in buffer the repeat records */
		while( j > 128 )
		{
			*cbp++ = 0x81; /* Repeat 128 times */
			*cbp++ = c;
			j -= 128;
		}
		if( j > 1 )
		{			/* Don't put in a one byte repeat! */
			*cbp++ = (byte)((-j) + 1);
			*cbp++ = c;
			j = 0;
		}
		last_i = i - j;		/* Mark our last index converted */
		i--;				/* Adjust for increment in for loop */
		p = (unsigned char*)(buf +i);		/* Get p back in sync */
	} /* end of for */
	/* Check to see if we need to send trailing literal records */
	if( ( j = (int)(ilen - last_i) ) > 0 )
	{
		/* dump max sized literal records first */
		while( j > 128 )
		{
			*cbp++ = 128 - 1;
			memcpy( cbp, &buf[last_i], 128 );
			cbp += 128;
			last_i += 128;
			j -= 128;
		}
		/* Send last literal record */
		*cbp++ = (byte)(j - 1);
		memcpy( cbp, &buf[last_i], (unsigned int)j );
		cbp += j;
	} /* end of if */
	return (unsigned int)(cbp - buf_comp);
} /* end of packbits() */
static unsigned int PackbitsEncode_3byte(unsigned char *buf_comp, 
						   unsigned char *buf, unsigned int ilen )
{
#define SAMPLE_BYTE 3
#define get_P_Sample(ptr)  ((*(int*)(ptr)) & 0x00ffffff)

	ilen = ilen/3;

	int c;
	unsigned char *p;
	unsigned char *cbp; /* Compressed buffer pointer */
	int i, j, last_i, end_loop;
	cbp = buf_comp;
	last_i = 0;
	end_loop = (int)(ilen - 2);




	for( p=buf, i=0; i<end_loop; p += SAMPLE_BYTE, i++ )
	{
		if( (c = get_P_Sample(p)) != get_P_Sample(p+SAMPLE_BYTE) )
			continue;
		/* If only a two byte repeat, and we have literal
		** data preceeding, then it is best to send the
		** two bytes as literal data. */
		if( (i != last_i) && (c != get_P_Sample(p+SAMPLE_BYTE+SAMPLE_BYTE)) )
			continue;
		/* We have found a repeated string. First send out the
		** literal string in front of it if needed. */
		if( ( j = i - last_i ) > 0 )
		{
			/* dump max sized literal records first */
			while( j > 128 ) {
				*cbp++ = 128 - 1;
				memcpy( cbp, buf +last_i*SAMPLE_BYTE, 128*SAMPLE_BYTE );
				cbp += 128*SAMPLE_BYTE;
				last_i += 128;
				j -= 128 ;
			}
			/* Send last literal record */
			*cbp++ = (byte)(j - 1);
			memcpy( cbp, buf +last_i*SAMPLE_BYTE, (unsigned int)j *SAMPLE_BYTE);
			cbp += j*SAMPLE_BYTE;
		}
		j = (int)(ilen - i - 1); /* Max we can check + 1 */
		p += (SAMPLE_BYTE + SAMPLE_BYTE);					   /* Start scanning two bytes ahead */
		while( --j > 0 )
		{
			if( c != get_P_Sample(p) )
				break;
			p+=SAMPLE_BYTE;
		}
		/* p now points to the first byte that doesn't compare */
		j = (int)(p - (buf +i*SAMPLE_BYTE))/SAMPLE_BYTE; /* Number of repeats */
		i += j;					/* Advance our index past repeats */
		/* Place in buffer the repeat records */
		while( j > 128 )
		{
			*cbp++ = 0x81; /* Repeat 128 times */
			*cbp++ = c&0xff;
			*cbp++ = (c>>8)&0xff;
			*cbp++ = (c>>16)&0xff;

			j -= 128;
		}
		if( j > 1 )
		{			/* Don't put in a one byte repeat! */
			*cbp++ = (byte)((-j) + 1);

			*cbp++ = c&0xff;
			*cbp++ = (c>>8)&0xff;
			*cbp++ = (c>>16)&0xff;

			j = 0;
		}
		last_i = i - j;		/* Mark our last index converted */
		i--;				/* Adjust for increment in for loop */
		p = (unsigned char*)(buf +i*SAMPLE_BYTE);		/* Get p back in sync */
	} /* end of for */
	/* Check to see if we need to send trailing literal records */
	if( ( j = (int)(ilen - last_i) ) > 0 )
	{
		/* dump max sized literal records first */
		while( j > 128 )
		{
			*cbp++ = 128 - 1;
			memcpy( cbp, &buf[last_i*SAMPLE_BYTE], 128*SAMPLE_BYTE );
			cbp += 128*SAMPLE_BYTE;
			last_i += 128;
			j -= 128;
		}
		/* Send last literal record */
		*cbp++ = (byte)(j - 1);
		memcpy( cbp, &buf[last_i*SAMPLE_BYTE], (unsigned int)j*SAMPLE_BYTE );
		cbp += j*SAMPLE_BYTE;
	} /* end of if */
	return (unsigned int)(cbp - buf_comp);
} /* end of packbits() */





void CBandDataPrepare::GetPostProcessMethod()
{
	//1 Whether Do Spectra serial
	int headtype = m_pParserJob->get_SPrinterProperty()->get_PrinterHead();
	m_bSpectra_serial = 
		(headtype == PrinterHeadEnum_Spectra_NOVA_256 ||
		headtype == PrinterHeadEnum_Spectra_GALAXY_256);
	//2 Whether Do Mask
	m_bHeadMask = false;
	const byte *pHeadMap =  m_pParserJob->get_SPrinterProperty()->get_pHeadMask();
	for (int i=0; i< MAX_HEAD_NUM;i++){
		if(pHeadMap[i] != 0){
			m_bHeadMask = true;
			break;
		}
	}

	m_bConvert16To12 = false;
	m_bTiffCompress = false;
	m_bPolaris4Color = false;
	m_bEpson5Compress = false;
	m_bEpson5 = false;
	m_bKm512GrayCompress = false;
	m_bEmeraldCompress = false;
	m_bKyocera = false;

	int headboardtype = get_HeadBoardType(false);
	if(( headtype == PrinterHeadEnum_Konica_KM256L_42pl ||
		headtype == PrinterHeadEnum_Konica_KM256M_14pl )
		&& 
		(headboardtype != HEAD_BOARD_TYPE_KM256_16HEAD))
		m_bConvert16To12 = true;

	if(IsRicohGen4(headtype)||IsRicohGen5(headtype)||IsEpsonGen5(headtype)||IsEpson5113(headtype)||IsEpson2840(headtype)||IsEpson1600(headtype)||IsXaar1201(headtype))
	{
		m_bEpson5 = true;
	}
	if(IsPolaris(headtype)
		/*&& m_pParserJob->get_SPrinterProperty()->get_ElectricNum() >16*/
#ifndef POLARIS_8HEAD_COMPRESS
		&& (m_pParserJob->get_SPrinterProperty()->get_BoardVersion()>>24) == 1
#endif
		)
	{
		m_bTiffCompress = true;
	}
	if(IsPolarisOneHead4Color(headtype))
	{
		m_bPolaris4Color = true;
	}

#ifndef DUMP_BANDDATA
	if(IsEmerald(headtype))
		m_bEmeraldCompress = true;
#endif
	if(m_nOutputColorDeep != 1)
	{
		m_bKm512GrayCompress = true;
		int nElectricNum = m_pParserJob->get_SPrinterProperty()->get_ElectricNum();
		int nNozzleNum = 	m_pParserJob->get_SPrinterProperty()->get_NozzleNum();
		int nHeadRowNum	= m_pParserJob->get_SPrinterProperty()->get_HeadRowNum();
		m_nCacheLineSize = m_nOutputColorDeep *
			nElectricNum * 
			nNozzleNum /
			nHeadRowNum / 8;
		if(IsKyocera600(headtype))
		{
			m_nCacheLineSize = m_nOutputColorDeep *
			nElectricNum * 
			nNozzleNum /nHeadRowNum / 8/m_nInputNum;

		}
		m_pCacheLineBuf = new unsigned char [m_nCacheLineSize];
	}
#ifdef CLOSE_TIFF_COMPRESS
	m_bTiffCompress = false;
#endif
	m_bX501MirrorLine = IsXaar501(headtype);
	if (m_bX501MirrorLine)
		m_bDualBandMode = true;
	if((IsXaar382(headtype)) && m_pParserJob->get_SPrinterProperty()->get_SupportDualBank())
	{
		m_bDualBandMode = false;
#ifdef DUALBANK_MODE
		m_bDualBandMode = true;
#endif
	}
}
static void ConvertBuffer(unsigned char *src)
{
	////////////////////////////////////
	for (int i=0;i<2;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = i;
	}

	////////////////////////////////////
	for (int i=0;i<127;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = i;
	}
	////////////////////////////////////
	for (int i=0;i<1;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = i;
	}
	////////////////////////////////////
	for (int i=0;i<128;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = i;
	}
	////////////////////////////////////
	for (int i=0;i<256;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = i;
	}

	////////////////////////////////////
	for (int i=0;i<2;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = 2;
	}

	////////////////////////////////////
	for (int i=0;i<127;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = 127;
	}
	////////////////////////////////////
	for (int i=0;i<1;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = 1;
	}
	////////////////////////////////////
	for (int i=0;i<128;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = 0xff;
	}
	////////////////////////////////////
	for (int i=0;i<252;i++)
	{
		*src++ = 0;
		*src++ = 0;
		*src++ = 0xfe;
	}
}

static void Dump(int bandIndex, unsigned char *buf,int size)
{
#define DUMP_BAND_NUM 10
	FILE *fp = 0;
	char filename[128];
	sprintf(filename,"e:\\%d.dat ",(bandIndex%DUMP_BAND_NUM));
  	fp= fopen(filename,"wb");
	 if(fp)
	 {
		fwrite(&bandIndex,1,4,fp);
		fwrite(buf,1, size,fp);
		fclose(fp);
	 }
}
static void Convert2BitRev(unsigned char *databuf, int idatasize ,int Bit1EpsonLine)
{
	int colsize = idatasize/(Bit1EpsonLine * 2);
	unsigned char * psrc1, * pdst1;
	for (int i=0;i<colsize;i++)
	{
		psrc1 =   (unsigned char *)databuf +  Bit1EpsonLine * 2 *i ;
		pdst1 = psrc1+ Bit1EpsonLine;
		//memset(psrc1,0x03, Bit1EpsonLine);
		//memset(pdst1,0x00, Bit1EpsonLine);
		for (int j=0; j< Bit1EpsonLine;j++)
		{
			unsigned char pchar = *pdst1;
			*pdst1++ = *psrc1;
			*psrc1++ = pchar;
		}
	}
}
static unsigned char Mirror2BitTable[0x100] = 
{
	0x0,0x40,0x80,0xc0,0x10,0x50,0x90,0xd0,	0x20,0x60,0xa0,0xe0,0x30,0x70,0xb0,0xf0,
	0x4,0x44,0x84,0xc4,0x14,0x54,0x94,0xd4,	0x24,0x64,0xa4,0xe4,0x34,0x74,0xb4,0xf4,
	0x8,0x48,0x88,0xc8,0x18,0x58,0x98,0xd8,	0x28,0x68,0xa8,0xe8,0x38,0x78,0xb8,0xf8,
	0xc,0x4c,0x8c,0xcc,0x1c,0x5c,0x9c,0xdc,	0x2c,0x6c,0xac,0xec,0x3c,0x7c,0xbc,0xfc,

	0x1,0x41,0x81,0xc1,0x11,0x51,0x91,0xd1,	0x21,0x61,0xa1,0xe1,0x31,0x71,0xb1,0xf1,
	0x5,0x45,0x85,0xc5,0x15,0x55,0x95,0xd5,	0x25,0x65,0xa5,0xe5,0x35,0x75,0xb5,0xf5,
	0x9,0x49,0x89,0xc9,0x19,0x59,0x99,0xd9,	0x29,0x69,0xa9,0xe9,0x39,0x79,0xb9,0xf9,
	0xd,0x4d,0x8d,0xcd,0x1d,0x5d,0x9d,0xdd,	0x2d,0x6d,0xad,0xed,0x3d,0x7d,0xbd,0xfd,

	0x2,0x42,0x82,0xc2,0x12,0x52,0x92,0xd2,	0x22,0x62,0xa2,0xe2,0x32,0x72,0xb2,0xf2,
	0x6,0x46,0x86,0xc6,0x16,0x56,0x96,0xd6,	0x26,0x66,0xa6,0xe6,0x36,0x76,0xb6,0xf6,
	0xa,0x4a,0x8a,0xca,0x1a,0x5a,0x9a,0xda,	0x2a,0x6a,0xaa,0xea,0x3a,0x7a,0xba,0xfa,
	0xe,0x4e,0x8e,0xce,0x1e,0x5e,0x9e,0xde,	0x2e,0x6e,0xae,0xee,0x3e,0x7e,0xbe,0xfe,

	0x3,0x43,0x83,0xc3,0x13,0x53,0x93,0xd3,	0x23,0x63,0xa3,0xe3,0x33,0x73,0xb3,0xf3,
	0x7,0x47,0x87,0xc7,0x17,0x57,0x97,0xd7,	0x27,0x67,0xa7,0xe7,0x37,0x77,0xb7,0xf7,
	0xb,0x4b,0x8b,0xcb,0x1b,0x5b,0x9b,0xdb,	0x2b,0x6b,0xab,0xeb,0x3b,0x7b,0xbb,0xfb,
	0xf,0x4f,0x8f,0xcf,0x1f,0x5f,0x9f,0xdf,	0x2f,0x6f,0xaf,0xef,0x3f,0x7f,0xbf,0xff
};  
void MirrorBuf2Bit(unsigned char * buf, int LineLen)
{
	for(int i =0;i<LineLen/2;i++)
	{
		unsigned char tmp = buf[i];
		buf[i]= Mirror2BitTable[buf[LineLen-1-i]];
		buf[LineLen-1-i]= Mirror2BitTable[tmp];
	}
	if(LineLen&1)
	{
		buf[LineLen /2]= Mirror2BitTable[buf[LineLen /2]];
	}
}
	

CPrintBand * CBandDataPrepare::PostProcessBand(CPrintBand * pPrintBand)
{
	CPrintBand * pDest = pPrintBand;
	unsigned char * const databuf = pPrintBand->GetBandDataAddr();
	uint idatasize = pPrintBand->GetBandDataSize();
	pPrintBand->SetCompressSize(idatasize);
	pPrintBand->SetCompressType(EP2CompressMode_None);

	if(m_bDualBandMode)
	{
		int nNozzleNum = m_pParserJob->get_SPrinterProperty()->get_NozzleNum();
		int compresssize = idatasize /2 ;
		unsigned char * psrc, * pdst,*ptmp;
		int blocksize = m_nRotateLineNum*nNozzleNum/8;
		int colsize = idatasize/(blocksize);
		pdst = psrc = databuf;
		
		for (int i=0;i<colsize;i++)
		{
			ptmp = psrc + blocksize/2;
			/*if (m_bX501MirrorLine)
				MirrorBuf2Bit(ptmp, blocksize/2);*/
			for (int n=0; n<blocksize/2;n++)
			{
				*pdst++ = (*psrc<<1) | (*ptmp++);
				psrc++;
			}
			psrc = ptmp;
		}

		pPrintBand->SetCompressSize(compresssize);
		pPrintBand->SetCompressType(EP2CompressMode_DualBank);
		idatasize /= 2;
	}
	if(m_bSpectra_serial)
	{
		int unit = 256/4 *sizeof(int);
		int colsize = idatasize/unit;
		unsigned char *psrc = (unsigned char *)databuf;
		unsigned char *pdst = (unsigned char *)databuf;

		for (int n = 0; n < colsize;n++)
		{
			memcpy(m_pSerialBuf,psrc,unit);
			/////Splite 32 to  16 bit;
			unsigned char *src =  m_pSerialBuf;
			unsigned char *dst  = pdst;
			int half = unit/2;
			for (int i=0; i< unit/2 ;i++)
			{
				byte dstchar1,dstchar2;
				unsigned short srcShort = ((int)(*(src+1) << 8) + (int)(*src));
				ConvertResX2Short((unsigned short)srcShort, dstchar1, dstchar2);

				//Second Version for 1- 4 Nozzle need Reverse
				*dst = dstchar1;
				*(dst + half) = dstchar2;

				dst++;
				src += 2;
			}

			psrc += unit;
			pdst += unit;
		}
	}

#ifdef CONVERT_EP2_16TO12
	if(m_bConvert16To12)
	{
		int compresssize = idatasize * 3/4 ;

		unsigned short * psrc, * pdst;
		pdst = psrc = (unsigned short *)databuf;
		int colsize = idatasize/(sizeof(unsigned short) * 4);
		for (int i=0;i<colsize;i++)
		{
			unsigned short src3 = *(psrc+3);
			* pdst++ = (*psrc++) |  ((src3 >>12)&0xf);
			* pdst++ = (*psrc++) |  ((src3 >>8)&0xf);
			* pdst++ = (*psrc++) |  ((src3>>4)&0xf);
			psrc++;
		}
		pPrintBand->SetCompressSize(compresssize);
		pPrintBand->SetCompressType(EP2CompressMode_16To12);
	}
#endif
	int headtype = m_pParserJob->get_SPrinterProperty()->get_PrinterHead();
	if(m_bEpson5)
	{
		int NozzleNum = m_pParserJob->get_SPrinterProperty()->get_NozzleNum();
		int Bit1EpsonLine = NozzleNum*m_nRotateLineNum/8;

		if(pPrintBand->GetBandDir() == 0)
		{
			Convert2BitRev(databuf,idatasize,Bit1EpsonLine);
		}

		if(m_bEpson5Compress)
		{
			int compresssize = idatasize * 1/2 ;
			unsigned char * psrc, * pdst;
			int colsize = idatasize/(Bit1EpsonLine * 2);
			for (int i=0;i<colsize;i++)
			{
				pdst =  (unsigned char *)databuf +  Bit1EpsonLine *i ;
				psrc = (unsigned char *)databuf +   Bit1EpsonLine*2 *i;
				for (int j=0; j< Bit1EpsonLine ;j++)
				{
					* pdst++ = *psrc;
					psrc += 2;
				}
			}
			pPrintBand->SetCompressSize(compresssize);
			pPrintBand->SetCompressType(EP2CompressMode_EPSON5);
		}
	}
	int speed = m_pParserJob->get_Global_IPrinterSetting()->get_PrinterSpeed();
	if (headtype == PrinterHeadEnum_RICOH_GEN4P_7pl)
	{
		int NozzleNum = m_pParserJob->get_SPrinterProperty()->get_NozzleNum();
		int Len = NozzleNum*m_nRotateLineNum/8;
		unsigned short *cache = new unsigned short[Len];
		memset(cache,0,Len*2);

		int firenum = idatasize/Len/2;
		unsigned short mask =0x5555;
		unsigned short * psrc,*pdst;
		unsigned short* cachebuf = new unsigned short[firenum*Len];
		memset(cachebuf,0,firenum*Len*2);

		for (int i=0;i<firenum;i++)
		{
			memset(cache,0,Len*2);
			psrc = (unsigned short *)databuf+i*Len;
			pdst = cachebuf+i*Len;
			for (int j=0; j<NozzleNum;j++)
			{
				cache[2*j] |= (*(psrc+j)&(~mask));
				cache[2*j+1]|= (*(psrc+j+NozzleNum)&(~mask));
				int k=0;
				if(j<96)
					k=96-j;
				else
					k=288-j;
				cache[2*(NozzleNum-k)] |=( *(psrc+j+NozzleNum)&mask);
				cache[2*(NozzleNum-k)+1] |=(*(psrc+j)&mask);
			}
			memcpy(pdst,cache,Len*2);
		}
		memcpy(databuf,cachebuf,firenum*Len*2);
		delete[] cache;
		delete[] cachebuf;
	}
#ifdef YAN2
	if (IsEpson5113(headtype) && (speed==0||speed==3))
	{
		int NozzleNum = m_pParserJob->get_SPrinterProperty()->get_NozzleNum();
		int Len = NozzleNum*m_nRotateLineNum/8;
		unsigned short *cache = new unsigned short[Len];
		memset(cache,0,Len*2);

		int firenum = idatasize/Len/2;;
		unsigned short* cachebuf = new unsigned short[firenum*Len];
		memset(cachebuf,0,firenum*Len*2);

		{
			unsigned short * src,*dst;
			for (int i=0;i<firenum;i++)
			{
				memset(cache,0,Len*2);
				src = (unsigned short *)databuf+i*Len;
				dst = (unsigned short *)cachebuf+i*Len;
				for (int j=0; j<NozzleNum;j++)
				{
					for(int k =0;k<m_nRotateLineNum/16;k++)
					{
						*((unsigned short *)cache+m_nRotateLineNum/16*j+k) =(*(src+m_nRotateLineNum/16*j+k))|(*(src+m_nRotateLineNum/16*(NozzleNum+j)+k));
						*((unsigned short *)cache+m_nRotateLineNum/16*j+k) = (*(src+m_nRotateLineNum/16*j+k))&(*(src+m_nRotateLineNum/16*(NozzleNum+j)+k));
						*((unsigned short *)cache+m_nRotateLineNum/16*j+k) =(*(src+m_nRotateLineNum/16*j+k))|(*(src+m_nRotateLineNum/16*(NozzleNum+j)+k));
						*((unsigned short *)cache+m_nRotateLineNum/16*(NozzleNum+j)+k) = (*(src+m_nRotateLineNum/16*j+k))&(*(src+m_nRotateLineNum/16*(NozzleNum+j)+k));
					}

				}
				memcpy(dst,cache,Len*2);
			}
		}
		memcpy(databuf,cachebuf,firenum*Len*2);
		delete[] cache;
		delete[] cachebuf;
	}
#endif
	if(m_bEmeraldCompress)
	{
#define COMPRESS_MULTIPLY 4
		int compresssize = idatasize/ COMPRESS_MULTIPLY;
		unsigned char * psrc, * pdst;
		int COLSIZE = 128 * m_nRotateLineNum/8;
		int DETASIZE = COLSIZE/COMPRESS_MULTIPLY;
		int DESTSIZE = 32 * m_nRotateLineNum/8;
		unsigned char DEST[32 * 8];
		int colsize = idatasize/(COLSIZE);

		int nBytePerPixel = m_nRotateLineNum/8; 
		for (int i=0;i<colsize;i++)
		{
			pdst = (unsigned char *)databuf +  COLSIZE/COMPRESS_MULTIPLY *i ;
			psrc = (unsigned char *)databuf +  COLSIZE *i;
			unsigned char *ptmp = DEST;
			for (int j=0; j< 32 ;j++)
			{
				unsigned short * PS1 = (unsigned short *)psrc;
				unsigned short * PS2 = (unsigned short *)(psrc+DETASIZE*1);
				unsigned short * PS3 = (unsigned short *)(psrc+DETASIZE*2);
				unsigned short * PS4 = (unsigned short *)(psrc+DETASIZE*3);
				for(int hd = 0; hd< nBytePerPixel * 2 ;hd  += 2)
				{
					* ptmp++     = ((*PS1>>hd)&3) + (((*PS2>>hd)&3)<<2) + (((*PS3>>hd)&3)<<4) + (((*PS4>>hd)&3)<<6);
				}
				 psrc += nBytePerPixel;
			}
			memcpy(pdst,DEST,DESTSIZE);
		}

		pPrintBand->SetCompressSize(compresssize);
		pPrintBand->SetCompressType(EP2CompressMode_Emerald);
	}
	if(m_bKm512GrayCompress && !m_bEpson5)
	{
		int Bit1EpsonLine = m_nCacheLineSize/m_nOutputColorDeep;

		bool BandDir = pPrintBand->GetBandDir();
		int compresssize = idatasize;
		const int COLSIZE = Bit1EpsonLine *m_nOutputColorDeep;
		unsigned char *DEST = m_pCacheLineBuf;
		int colsize = idatasize/(COLSIZE);
		int head_type = m_pParserJob->get_SPrinterProperty()->get_PrinterHead();
		
		if (m_nOutputColorDeep == 2){
			if (IsKonica512i(head_type) || IsKonica1024(head_type) || IsKonica1024i(head_type)){
				BandDir = !BandDir;
			}
			LARGE_INTEGER tick_start;
			LARGE_INTEGER tick_end;
			QueryPerformanceCounter(&tick_start);
			shuffle_quick_2bit(databuf, m_nCacheLineSize / 2, idatasize, BandDir);
			QueryPerformanceCounter(&tick_end);
			GrayConver->SetTimer(tick_end.QuadPart - tick_start.QuadPart);
			GrayConver->SetDataSize(compresssize);
		}
		//if(m_nOutputColorDeep == 2)
		//{
		//	unsigned char * psrc,* psrc1, * pdst,*pdst1;
		//	for (int i=0;i<colsize;i++)
		//	{
		//		if(BandDir != 0)
		//		{
		//				psrc = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*0;
		//				psrc1 = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*1;
		//		}
		//		else
		//		{
		//				psrc = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*1;
		//				psrc1 = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*0;
		//		}
		//		pdst =  (unsigned char *)databuf + COLSIZE *i ;
		//		pdst1 =  DEST;
		//		for (int j=0; j< COLSIZE/m_nOutputColorDeep ;j++)
		//		{
		//			unsigned short tempShort = 0;
		//			ConvertByteToShort(tempShort,*psrc1,*psrc);
		//			psrc ++;
		//			psrc1++;
		//			* pdst1++ = (tempShort&0xff);
		//			* pdst1++ = (tempShort>>8)&0xff;
		//		}
		//		memcpy(pdst,DEST,COLSIZE);
		//	}
		//}
		else if(m_nOutputColorDeep == 3)
		{
			unsigned char * psrc,* psrc1, * psrc2,* pdst,*pdst1;
			for (int i=0;i<colsize;i++)
			{
				if(BandDir != 0)
				{
						psrc = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*0;
						psrc1 = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*1;
						psrc2 = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*2;
				}
				else
				{
						psrc = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*2;
						psrc1 = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*1;
						psrc2 = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*0;
				}
				pdst =  (unsigned char *)databuf + COLSIZE *i ;
				pdst1 =  DEST;
				for (int j=0; j< COLSIZE/m_nOutputColorDeep ;j++)
				{
					unsigned int tempShort = 0;
					ConvertByteToShort_3Bit(tempShort,*psrc2,*psrc1,*psrc);

					psrc ++;
					psrc1++;
					psrc2++;
					* pdst1++ = (tempShort&0xff);
					* pdst1++ = (tempShort>>8)&0xff;
					* pdst1++ = (tempShort>>16)&0xff;
				}
				memcpy(pdst,DEST,COLSIZE);
			}
		}

		pPrintBand->SetCompressSize(compresssize);
		pPrintBand->SetCompressType(EP2CompressMode_KM512Gray);
	}
	//if(m_bKyocera)
	if (0)
	{
		int headboardtype = get_HeadBoardType(false);

		int Bit1EpsonLine = m_nCacheLineSize/m_nOutputColorDeep;
		bool BandDir = pPrintBand->GetBandDir();
		int compresssize = idatasize ;
		const int COLSIZE = Bit1EpsonLine *m_nOutputColorDeep;
		unsigned char *DEST = m_pCacheLineBuf;
		int colsize = idatasize/(COLSIZE);
		if(m_nOutputColorDeep == 2)
		{
			unsigned char * psrc,* psrc1, * pdst,*pdst1;

			for (int i=0;i<colsize;i++)
			{
				if(BandDir != 0)
				{
						psrc = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*0;
						psrc1 = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*1;
				}
				else
				{
						psrc = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*1;
						psrc1 = (unsigned char *)databuf +   COLSIZE *i + Bit1EpsonLine*0;
				}
				pdst =  (unsigned char *)databuf + COLSIZE *i ;
				pdst1 =  DEST;
				for (int j=0; j< COLSIZE/m_nOutputColorDeep ;j++)
				{
					unsigned short tempShort = 0;
					ConvertByteToShort(tempShort,*psrc1,*psrc);

					psrc ++;
					psrc1++;

					* pdst1++ = (tempShort>>8)&0xff;
					* pdst1++ = (tempShort&0xff);
				}
				memcpy(pdst,DEST,COLSIZE);
			}
		}
		else if(m_nOutputColorDeep == 1)
		{
			unsigned char * psrc, * pdst;
			psrc = (unsigned char *)databuf;
			pdst =  (unsigned char *)databuf;
			for (int i=0;i<idatasize;i++)
			{
				*pdst++ = ((*psrc<<4)&0xF0)|((*psrc>>4)&0xF);
				psrc++;
			}
		}

		pPrintBand->SetCompressSize(compresssize);
		pPrintBand->SetCompressType(EP2CompressMode_KM512Gray);
	}	
	if(m_bPolaris4Color)
	{
		int OneFire = 128 * 2;
		int FireNum = idatasize/OneFire;


		for (int i=0; i< FireNum ;i++)
		{
			unsigned char *psrc = (unsigned char *)databuf + i*OneFire;
			unsigned char *pdst = psrc + (57+7+7)*2+1;
			for(int j=0; j< 57;j++)
			{
				*pdst = *psrc;
				*psrc = 0;
				pdst += 2;
				psrc += 2;
			}
		}
	}
	if(m_bHeadMask)
	{
		unsigned char *databuf = pPrintBand->GetBandDataAddr();
#define TOOLS_CHECK_CHANEL 
		const byte *pHeadMask =  m_pParserJob->get_SPrinterProperty()->get_pHeadMask();
		int div = 1;
		if(m_bDualBandMode)
			div = 2;
		int detacol = m_pParserJob->get_SPrinterProperty()->get_ElectricNum()*div*m_nOutputColorDeep/8;
		if(detacol <1)
			detacol = 1;
		int colsize = idatasize/detacol;
		unsigned char *psrc = (unsigned char *)databuf;
		for (int n = 0; n < colsize/2;n++)
		{
#ifdef TOOLS_CHECK_CHANEL
			for (int m = 0; m < detacol;m++)
			{
				*psrc++ = (pHeadMask[m]);
			}
			for (int m = 0; m < detacol;m++)
			{
				*psrc++ = 0;
				//*psrc++ = (pHeadMask[m]);
			}

#else
			for (int m = 0; m < detacol;m++)
			{
				*psrc++ = *psrc & (~pHeadMask[m]);
			}
#endif
		}
	}
	if(m_bTiffCompress)
	{
		pDest = pPrintBand->Clone(USB_EP2_DATA_ALIGNMENT(idatasize / 64 * 65) );

		unsigned char *comBuf = pDest->GetBandDataAddr();
		uint max_comSize = pDest->GetBandDataSize();

		if(/*databuf != 0 &&*/ idatasize > 0) //在1345行memcpy中初始化了
		{
			int comsize = PackbitsEncode(comBuf,databuf,idatasize);

			//Compress
			int leftsize = max_comSize - comsize;
			memset(comBuf+comsize,0,leftsize);

			pDest->SetCompressSize(comsize);
			pDest->SetCompressType(EP2CompressMode_Tiff);
		}
		delete pPrintBand;
	}


	return pDest;
}

